
main(/)
	
	
	
*** TO DO
*** ошибка в делении или нет? в питоне и калькуляторе разные значения
*** python3 hex(int(0x966AA219284F4DAF/0x3))
*** n = 1 
*** если малое частное L4 помещается в L2 записать туда, вернуть Q4 = 0 иначе вернуть L4, как большое число
*** если числа закончились сохранить последнее частное с остатком от деления равным 0, можно использовать комплекс L4 с добавлением флага, указывающего на вид выхода. Возможно у меня это комплекс L8
*** посчитать количество нулей, это будут степени двойки
*** завести второй массив со степенями чисел из массива делителей
*** http://planetcalc.com/3754/


	*** *test(/)
	 *test_tdmBN(/)
	*** *tdm_t(/)
	*** *test_chisla(/)
**


test_chisla(/)
	@+L1(5)
	@+L2(5)
	2=Q1
	1=Q2
	
	6h=L1.1
	1879E808h=L1.0
	337=L2.0
	L1;L2=L2
	/'L2 = '>C *HprintfBN(L2/) /'\n'>C
	/'L2.0 = '>C *Hprintf(L2.0/) /'\n'>C
	
**



test_Z(/)
	
	
	ffffffffh=t
	OZ *printf(Z/) /' '>C *printf(t/) /' '>C
	t+2=t
	*printf(Z/) /' '>C *printf(t/) /'\n'>C 
	
	
**



test(/)
	@+L1(10)
	@+L2(100)
	@+L3(100)
	
	*** 26=l
	*** 432=l
	*** 65343=l
	*** 65535=l
	*** 65536=l
	l=k=L1.0 1=Q1
	*trial_division_method_v2(k/L2, L3)
	Oi
	P1 *printf(L2i/) /'^'>C *printf(L3i/)
		Di /' '>C ?(i<Q2)1
	*** *printf(k/)
	/'\n'>C
	*** *tdmBN(L1/L2, L3) Oi
	*** P2 *printf(L2i/) Di /' '>C ?(i<Q2)2
	*** /'\n'>C
	*** /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	P3 
	
**

test_tdmBN(/)
	
	@+L1(10)
	@+L2(100)
	@+F3(100)
	@+L4(100)
	@+L5(100)
	
	*** OQ3 @'0x1ffffffffffffffffffffff'>F3
	*** OQ3 @'0x1ffffff12312312'>F3
	*** OQ3 @'0x7ffffffffffffffffffffffffff'>F3
	*** OQ3 @'0x40810204081'>F3
	*** OQ3 @'0x40810204080'>F3
	*** OQ3 @'0x966AA219284F4DAF'>F3
	*** OQ3 @'0xffffffff'>F3
	OQ3 @'0x10000'>F3
	
	OQ1=Q2=i
	*inputBN(L1, F3, i/L1, i)
	/'До tdmBN\n'>C
	/'Q1 = '>C *Hprintf(Q1/) /'\n'>C
	/'L1 = '>C *HprintfBN(L1/) /'\n'>C
	/'Внутри tdmBN\n'>C
	*** *tdmBN_ndc(L1/L2, L4) Oi
	*tdmBN(L1/L2, L4, L5) Oi
	/'После tdmBN\n'>C
	/'Q2 = '>C *printf(Q2/) /'\n'>C
	*** P2 *printf(L2i/) /' '>C Di ?(i<Q2)2
	P2 *printf(L2i/) /'^'>C *printf(L5i/) /' '>C Di ?(i<Q2)2
	/'\n'>C
	/'L4 = '>C *HprintfBN(L4/) /'\n'>C
	/'L1 = '>C *HprintfBN(L1/) /'\n'>C
	
**


*** Метод пробных делений на больших числах
*** на входе всегда нечётное число
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** L9 - степени сомножителей
*** s -  степень числа
tdmBN_(L1/L3, L4, L9)
	@+L7(100) ***(Q1)
	@+L2(100)
	@+L5(100)
	*countZeroesBN(L1/s)
	?(s=0)11 2=L3j s=L9j Dj OL9j
	P11 Q1=Q7 L1=L7 L1>s=L1 *compressBN(L1/L1)
		 ?(Q1>1)8 L1.0=n *trial_division_method_v2(n/L2, L5) Oi
	P12
		 ?(i>=Q2)9 L2i=L3j L5i=L9j Di ∆j=Q3=Q9 ?=12
	P8
		 @+L6(1)
		 100=Q2 *recalcefficients(L2, 3/L2) 1=Q4=Q5=Q6 OQ3=f
		 3=L6.0
		 
		 *BN_less(L1, L6/b) ?(b=1)6
		 Oi *** возможно придётся i присваивать 1
	P1 1=L6.0 *BN_eq(L4, L6/b) ?(b=1)9
		 *** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	P2 ?(L2i<3)10 L2i=L6.0
		 L1;L6=L5 *compressBN(L5/L5) L1/L6=L4 *compressBN(L4/L4) OL6
		 *BN_neq(L5, L6/b) ?(b#0)4
		 1=f ∆L9j L2i=L3j Q4=Q1 L4=L1 ?=1
	P4 L2i=L6.0
		 *BN_greq(L6, L4/b)
		 ?(b=1)5
		Di j+f=j Of=L9j ?(i<Q2)2 Oi Q2-1=l *recalcefficients(L2, L2l/L2)
		?=1 *** возможно придётся i присваивать 1
	P5 ?(Q1>1)13 j+f=j Of L1.0=L3j ∆L9j ∆j OQ4 ?=9
	P13
		 Q1=Q4 L1=L4 *compressBN(L4/L4) ?=9
	P6 /'Число должно быть больше 2'>C
	P10 /'unsigned int числа закончились\n'>C
	P9 j+f=Q3=Q9 Q7=Q1 L7=L1
**






*** Метод пробных делений на больших числах без комплекса степеней чисел
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** здесь j это t, а i это k
*** все сравнения BN_*(*/?) делаются без учёта мощностей комплексов(больших чисел), потому что результаты арифметических операций над ними не возвращают новую мощность результата 08.12.2015
*** s -  степень числа
*** ndc - no degrees complex
tdmBN_ndc(L1/L3, L4)
	@+L7(100) ***(Q1)
	@+L2(100)
	*countZeroesBN(L1/s) s=t
	Q1=Q7 L1=L7 *compressBN(L1/L1)
	P12 ?(t=0)11 2=L3j Dj Yt ?=12
	P11 
		 ?(Q1>1)8 L1.0=n *trial_division_method(n/L2) Oi
	P13
		 ?(i>=Q2)9 L2i=L3j Di Dj=Q3 ?=13
	P8
		 @+L5(100)
		 @+L6(1)
		 
		 100=Q2 *recalcefficients(L2, 3/L2) 1=Q4=Q5=Q6 OQ3
		 3=L6.0
		 *BN_less(L1, L6/b) ?(b=1)6 L1>s=L1 *compressBN(L1/L1)
		 Oi *** возможно придётся i присваивать 1
	P1 1=L6.0 *BN_eq(L4, L6/b)
		 ?(b=1)9
		 *** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	P2 ?(L2i<3)10 L2i=L6.0
		 L1;L6=L5 *compressBN(L5/L5) L1/L6=L4 *compressBN(L4/L4) OL6
		 *BN_neq(L5, L6/b)
		 ?(b#0)4
		 *** Возможна ошибка, если мощность комплекса больше 1, но число равно 0
		 L2i=L3j
		 Dj L4=L1 ?=1
	P4 L2i=L6.0
		 *** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		 *BN_greq(L6, L4/b)
		 ?(b=1)5
		Di ?(i<Q2)2 Oi Q2-1=l *recalcefficients(L2, L2l/L2)
		*** *printf(L2.0/) /'\n'>C *printf(L2.1/) /'\n'>C *printf(L2.2/) /'\n'>C *printf(L2.3/) /'\n'>C
		?=1 *** возможно придётся i присваивать 1
	P5 ?(Q1>1)14 L1.0=L3j Dj OQ4 ?=9
	P14
		 Q1=Q4 L1=L4 *compressBN(L4/L4)
		 *** /'Q1 = '>C *Hprintf(Q4/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L4/) /'\n'>C
		 ?=9
	P6 /'Число должно быть больше 2'>C
	P10 /'unsigned int числа закончились\n'>C
	P9 j=Q3=Q9 Q7=Q1 L7=L1
		 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
		 *** /'Q7 = '>C *printf(Q7/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 *** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
**






*** функция сжимает большое число - уменьшает его мощность, если впереди есть нулевые элементы
*** применяется после арифметических операций, где возможно уменьшение мощности числа, но сами арифметические операции его не уменьшают 08.12.2015
compressBN(L1/L1)
	Q1-1=i
	?(Q1=1)2
	P1 ?(L1i>0)2 Yi ?(i=0)2 ?=1
	P2 i+1=Q1
**


*** на входе всегда нечётное число
*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
trialdivisionmethod(n/L2)
	
	@+L1(4)
	4=Q1 *recalcefficients(L1, 3/L1)
	
	?(n<2)6
	*** n;2=k ?(k=0)4 *** k?-4 одно и тоже с ?(k=0)4, но не работает
	Oi=j *** возможно придётся i присваивать 1
	P1 ?(n=1)7 /'n = '>C *printf(n/) /'\n'>C
	P2 OZ n:L1i=q Z=r /'P2\n'>C ?(r#0)4 *** n;L1i=r n/L1i=q ?(r#0)4
	P3 L1i=L2j Dj q=n /'P3\n'>C ?=1
	P4 /'P4 '>C /'L1i = '>C *printf(L1i/) /'\n'>C ?(L1i>=q)5 /'after condition'>C
		 Di /'P4.2\n'>C ?(i<Q1)2 /'P4.3\n'>C Oi *recalcefficients(L1, L1.3/L1)
		 /'L1.3 = '>C *printf(L1.3/) /'\n'>C
		 ?=1 *** возможно придётся i присваивать 1
	P5 n=L2j Dj ?=7
	P6 /'Число должно быть больше 1'>C
	P7 j=Q2
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method на маленьком числе
*** и большом числе, с условием, что большое число не предполагается делить на другое большое число
*** мощность комплекса всегда должна быть чётной
recalcefficients(L1, k/L1)
	k=L1.0=l 2=d Oi+1=i
	P1 l+d=L1i=l Di d;4+2=d ?(i<Q1)1 Oi
	P2 *** *printf(L1i/) /' '>C Di ?(i<Q1)2 /'\n'>C
**


*** проверка, что 2 больших числа равны
*** BN_eq(L1, L2/b)

*** проверка, что большое число L1 больше числа L2
*** BN_gr(L1, L2/b)

*** проверка, что большое число L1 меньше числа L2
*** BN_less(L1, L2/b)

*** проверка, что большое число L1 больше или равно числу L2
*** BN_greq(L1, L2/b)

*** проверка, что большое число L1 меньше или равно числу L2
*** BN_leq(L1, L2/b)

*** проверка, что 2 больших числа не равны
*** BN_neq(L1, L2/b)










