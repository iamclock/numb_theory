
main(/)
	
	
	
*** TO DO
*** добавить проверку делителей на границу unsigned int
*** ошибка в делении или нет? в питоне и калькуляторе разные значения
*** python3 hex(int(0x966AA219284F4DAF/0x3))
	*** *test(/)
	*test_tdmBN(/)
**


test_Z(/)
	
	
	ffffffffh=t
	OZ *printf(Z/) /' '>C *printf(t/) /' '>C
	t+2=t
	*printf(Z/) /' '>C *printf(t/) /'\n'>C 
	
	
**



test(/)
	@+L1(10)
	@+L2(100)
	@+L3(100)
	
	
	257=k=L1.0 1=Q1
	*trialdivisionmethod(k/L2)
	Oi
	P1 *printf(L2i/) Di /' '>C ?(i<Q2)1
	/'\n'>C
	*tdmBN(L1/L2, L3) Oi
	P2 *printf(L2i/) Di /' '>C ?(i<Q2)2
	/'\n'>C
	/'L5 = '>C *HprintfBN(L5/) /'\n'>C
	P3 
	
**

test_tdmBN(/)
	
	@+L1(10)
	@+L2(100)
	@+F3(100)
	@+L4(100)
	
	*** OQ3 @'0x1ffffffffffffffffffffff'>F3
	*** OQ3 @'0x1ffffff12312312'>F3
	*** OQ3 @'0x7ffffffffffffffffffffffffff'>F3
	OQ3 @'0x40810204081'>F3
	*** OQ3 @'0x966AA219284F4DAF'>F3
	
	OQ1=Q2=i
	*inputBN(L1, F3, i/L1, i)
	
	*tdmBN(L1/L2, L4) Oi
	/'Q2 = '>C *printf(Q2/) /'\n'>C
	P2 *printf(L2i/) Di /' '>C ?(i<Q2)2
	/'\n'>C
	/'L4 = '>C *HprintfBN(L4/) /'\n'>C
	/'L1 = '>C *HprintfBN(L1/) /'\n'>C
	
**


*** Метод пробных делений на больших числах
*** на входе всегда нечётное число
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** здесь j это t, а i это k
*** все сравнения BN_*(*/?) делаются без учёта мощностей комплексов(больших чисел), потому что результаты арифметических операций над ними не возвращают новую мощность результата 08.12.2015
tdmBN(L1/L3, L4)
	?(Q1>1)8 L1.0=n *trial_division_method(n/L3) ?=9
	P8
	@+L2(100)
	*** @+L4(100)
	@+L5(100)
	@+L6(1)
	3=L2.0 5=L2.1 7=L2.2 11=L2.3 100=Q2 *recalcefficients(L2, 3/L2) 1=Q4=Q5=Q6 OQ3
	3=L6.0
	*BN_less(L1, L6/b) ?(b=1)6
	*** n;2=k ?(k=0)4 *** k?-4 одно и тоже с ?(k=0)4, но не работает
	Oi=j *** возможно придётся i присваивать 1
	P1 1=L6.0 *BN_eq(L4, L6/b)
	*** /'P1 b = '>C *printf(b/) /'\n'>C
	?(b=1)7
	*** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	
	P2 ?(L2i<3)10 L2i=L6.0
	*** /'L2i = '>C *Hprintf(L2i/) /'\n'>C
	*** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
	*** /'Q1 = '>C *Hprintf(Q1/) /'\n'>C
	*** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
	L1;L6=L5 *compressBN(L5/L5) L1/L6=L4 *compressBN(L4/L4) OL6
	*** /'Q5 = '>C *printf(Q5/) /'\n'>C
	*** /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	*** /'Q4 = '>C *printf(Q4/) /'\n'>C
	*** /'L4 = '>C *HprintfBN(L4/) /'\n'>C
	*BN_neq(L5, L6/b)
	*** /'P2 b = '>C *printf(b/) /'\n'>C
	?(b#0)4
	*** ?(L5>0)4 *** не фурычит
	*** надо будет пересчитать мощность L4 и L5
	*** Возможна ошибка, если мощность комплекса больше 1, но число равно 0
	P3 L2i=L3j
		 /'L2i = '>C *Hprintf(L2i/) /'\n'>C
		 /'L5 = '>C *HprintfBN(L5/) /'\n'>C
		 Dj L4=L1 ?=1
	P4 L2i=L6.0 *** /'L6 = '>C *printf(L6.0/) /'\n'>C
	*** /'L4 = '>C *HprintfBN(L4/) /'\n'>C
	*BN_greq(L6, L4/b) *** /'P4 b = '>C *printf(b/) /'\n'>C
	?(b=1)5
		Di ?(i<Q1)2 Oi Q2-1=l *recalcefficients(L2, L2l/L2)
		*** *printf(L2.0/) /'\n'>C *printf(L2.1/) /'\n'>C *printf(L2.2/) /'\n'>C *printf(L2.3/) /'\n'>C
		?=1 *** возможно придётся i присваивать 1
	P5
		 Q1=Q4 L1=L4
		 /'Q1 = '>C *Hprintf(Q4/) /'\n'>C
		 /'L1 = '>C *HprintfBN(L4/) /'\n'>C
		 ?=7
	P6 /'Число должно быть больше 2'>C
	P7 j=Q3 ?=9
	P10 /'unsigned int числа закончились\n'>C
	P9
**


*** функция сжимает большое число - уменьшает его мощность, если впереди есть нулевые элементы
*** применяется после арифметических операций, где возможно уменьшение мощности числа, но сами арифметические операции его не уменьшают 08.12.2015
compressBN(L1/L1)
	Q1-1=i
	P1 ?(L1i>0)2 Yi ?(i=0)2 ?=1
	P2 i+1=Q1
**

*** на входе всегда нечётное число
*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
trialdivisionmethod(n/L2)
	
	@+L1(4)
	3=L1.0 5=L1.1 7=L1.2 11=L1.3 4=Q1
	
	?(n<2)6
	*** n;2=k ?(k=0)4 *** k?-4 одно и тоже с ?(k=0)4, но не работает
	Oi=j *** возможно придётся i присваивать 1
	P1 ?(n=1)7
	P2 OZ n:L1i=q Z=r ?(r#0)4 *** n;L1i=r n/L1i=q ?(r#0)4
	P3 L1i=L2j Dj q=n ?=1
	P4 ?(L1i>=q)5
		 Di ?(i<Q1)2 Oi *recalcefficients(L1/L1) ?=1 *** возможно придётся i присваивать 1
	P5 n=L2j Dj ?=7
	P6 /'Число должно быть больше 1'>C
	P7 j=Q2
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method на маленьком числе
*** и большом числе, с условием, что большое число не предполагается делить на другое большое число
*** мощность комплекса всегда должна быть чётной
recalcefficients(L1, k/L1)
	k=L1.0=l 2=d Oi+1=i
	P1 l+d=L1i=l Di d;4+2=d ?(i<Q1)1 Oi
	P2 *** *printf(L1i/) /' '>C Di ?(i<Q1)2 /'\n'>C
**



*** проверка, что 2 больших числа равны
*** BN_eq(L1, L2/b)

*** проверка, что большое число L1 больше числа L2
*** BN_gr(L1, L2/b)

*** проверка, что большое число L1 меньше числа L2
*** BN_less(L1, L2/b)

*** проверка, что большое число L1 больше или равно числу L2
*** BN_greq(L1, L2/b)

*** проверка, что большое число L1 меньше или равно числу L2
*** BN_leq(L1, L2/b)

*** проверка, что 2 больших числа не равны
*** BN_neq(L1, L2/b)










