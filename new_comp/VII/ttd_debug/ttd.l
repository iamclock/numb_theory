main(/)
	@+L2(10)
	
	
	
	
	
	
	
	81=k
	*trial_division_method(k/L2)
	
	Oi
	P1 ?(i>=Q2)2 *printf(L2i/) Di /' '>C ?=1
	
	
	
	P2 /'\n'>C
	
**


*** Метод пробных делений на больших числах
*** на входе всегда нечётное число
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** здесь j это t, а i это k
tdmBN(L1/L3)
	@+L2(4)
	@+L4(100)
	@+L5(100)
	@+L6(1)
	3=L2.0 5=L2.1 7=L2.2 11=L2.3 4=Q1 1=Q4=Q5=Q6
	2=L6.0
	*BN_less(L1, L6/b) ?(b=1)6
	*** n;2=k ?(k=0)4 *** k?-4 одно и тоже с ?(k=0)4, но не работает
	Oi=j *** возможно придётся i присваивать 1
	P1 1=L6.0 *BN_eq(L1, L4/b) ?(b=1)7 *** проверка может пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	P2 L2i=L6.0 L1;L6=L5 L1/L6=L4 OL6 *BN_neq(L5, L6/b) ?(b#0)4 *** надо будет пересчитать 
																															*** мощность L4 и L5
																															*** возможна ошибка, если мощность комплекса больше 1, но число равно 0
	
	P3 L2i=L3j Dj L4=L1 ?=1
	P4 L2i=L6.0 *BN_greq(L4, L6/b) ?(b=1)5
		 Di ?(i<Q1)2 Oi *recalc_efficients(L2/L2) ?=1 *** возможно придётся i присваивать 1
	P5
		 n=L3j Dj ?=7
	P6 /'Число должно быть больше 1'>C
	P7 j=Q3
**



*** на входе всегда нечётное число
*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
trial_division_method(n/L2)
	
	@+L1(4)
	3=L1.0 5=L1.1 7=L1.2 11=L1.3 4=Q1
	
	?(n<2)6
	*** n;2=k ?(k=0)4 *** k?-4 одно и тоже с ?(k=0)4, но не работает
	Oi=j *** возможно придётся i присваивать 1
	P1 ?(n=1)7
	P2 n;L1i=r n/L1i=q ?(r#0)4
	P3 L1i=L2j Dj q=n ?=1
	P4 ?(L1i>=q)5
		 Di ?(i<Q1)2 Oi *recalc_efficients(L1/L1) ?=1 *** возможно придётся i присваивать 1
	P5
		 n=L2j Dj ?=7
	P6 /'Число должно быть больше 1'>C
	P7 j=Q2
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method на маленьком числе
*** и большом числе, с условием, что большое число не предполагается делить на другое большое число
recalc_efficients(L1/L1)
	Q1=t-1=l t;2=t L1l=l 4=d Oi
	?(t#0)2
	P1 2=d
	P2 l+d=L1i=l Di d;4+2=d ?(i<Q1)2 Oi
	P3 *printf(L1i/) /' '>C Di ?(i<Q1)3 /'\n'>C
**





trial_division_method(n/)
	@+L1(4)
	
	*** проверить n>1
	
	n;2=k ?(k=0)4 *** k?-4 одно и тоже с ?(k=0)4, но не работает
	
	3=L1.0 5=L1.1 7=L1.2 11=L1.3
	4=Q1 Q1-1=j
	1=s
	
	
	P1 Oi
		 *printf(L1.0/) /'\n'>C
		 *printf(L1.1/) /'\n'>C
		 *printf(L1.2/) /'\n'>C
		 *printf(L1.3/) /'\n'>C
		 
		 
		 
	P2 
		 L1j+2=L1i i=j Di
		 L1j+4=L1i i=j Di
		 ?(i#Q1)2 Ys ?(s>0)1
	?=5
	
	
	
	
	P4
		 /'Число составное\n'>C
	
	P5
**



*** проверка, что 2 больших числа равны
*** BN_eq(L1, L2/b)

*** проверка, что большое число L1 больше числа L2
*** BN_gr(L1, L2/b)

*** проверка, что большое число L1 меньше числа L2
*** BN_less(L1, L2/b)

*** проверка, что большое число L1 больше или равно числу L2
*** BN_greq(L1, L2/b)

*** проверка, что большое число L1 меньше или равно числу L2
*** BN_leq(L1, L2/b)

*** проверка, что 2 больших числа не равны
*** BN_neq(L1, L2/b)










