main(/)
	
	
	
	*testcz(/)
	*** *testmr(/)
	*testmrBN(/)
	
	
	
	
	
**



testcz(/)
	@+L1(100)
	@+L2(100)
	@+F3(100)
	
	OQ3=Q1=i
	*** @'0x'>F3
	*** @'0x'>F3
	*** @'0x'>F3
	*** @'0x'>F3
	*** @'0x'>F3
	
	*** *inputBN(L1, F3, i/L1, i)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*countZeroesBN(L1/s)
	/'s = '>C *printf(s/) /'\n'>C
	
	
**



testmrBN(/)
	@+L1(100)
	@+L2(100)
	@+F3(100)
	
	*** '0x1ffffffffffffffffffffff' - простое число
	OQ3 @'0x1ffffffffffffffffffffff'>F3
	
	OQ1=Q2=i
	*inputBN(L1, F3, i/L1, i)
	*** *inputBN(L2, F3, i/L2, i)
	
	32=L2.0 1=Q2
	
	*miralBN(L1, L2/b)
	
	
**



testmr(/)
	
	@+L1(100)
	*** @+L2(100)
	*** @+F3(100)
	
	On
	6679881=n *** - не простое число
	*** 96558=n *** - не простое число
	*** 524287=n *** - простое число
	*** 2147483647=n *** - простое число
	*** 1073676287=n *** - простое число
	
	OQ1
	*trial_division_method(n/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	
	*miral(n, 32/b)
	
	?(b=1)2 ?(b=0)1 ?=3
	
	P1 /'Составное\n'>C ?=3
	P2 /'Вероятно простое\n'>C
	P3 
	
**


*** miller-rabin-algorithm()
*** L2 - количество раундов, есть ли смысл делать большим числом?
*** может ли степень s быть больше 32 бит?
*** L1 - n простое нечётное число
*** 
*** 
*** 
*** 
miralBN(L1, L2/b)
	@+L3(20) *** m = n-1 (L1-1)
	@+L4(20) *** q
	@+L5(20) *** t
	@+L6(20) *** i, промежуточный комплекс
	@+L7(20) *** a
	@+L8(20) *** 
	@+L9(20) *** 
	@+L10(20) *** x
	*** @+L11(20) *** j
	
	
	1=L3.0 2=L6.0=L4.0 1=Q6=Q4 Ob
	Q1=Q3 L1-L3=L3 *** L3 теперь m = n-1 (L1-1)
	*countZeroesBN(L3/s) 
	*powBN2(L4, L6/L4) L3/L4=L5
	OL6.0=j=L7.0 1=Q7=Q8=L9.0=Q9 2=L8.0
	P1 BN_greq(L6, L2/b) ?(b=1)4 L7+L8=L7
		 *powBN(L7, L5, L1/L10) L6+L9=L6
		 BN_eq(L10, L9/b) ?(b=1) 1=j
		 BN_eq(L10, L3/b) ?(b=1)
		 
	
	
**



*** возможно ли, что степень двойки будет большим числом?
*** проблема - может прийти комплекс с мощностью больше 1, но равный нулю
countZeroesBN(L1/s)
	?(Q1=0)4 Oi=s ?(Q1>1)1 ?(L1.0=0)5
	P1 ?(i>=Q1)3 ?(L1i#0)2 s+32=s Di ?=1
	P2 *countZeroes(L1i/b) /'czs = '>C *printf(s/) /'\n'>C
		 /'b = '>C *printf(b/) /'\n'>C
		 s+b=s
	P3 s/Q1=t s;Q1=l t+l=l ?(l=32)5 ?=6
	P4 /'ОШИБКА: Мощность комплекса равна нулю\n'>C
	P5 Os /'ОШИБКА: Комплекс полностью из нулей\n'>C
	P6
**


countZeroes(x/s)
	Os ?(x=0)2 1=t t&x=a
	P1 ?(a#0)2 Ds t<1=t t&x=a ?=1
	P2
**




*** Тест Миллера-Рабина
*** возвращает значение b равное 1, если вероятно простое, 0, если составное
*** n - проверяемое число, r - количество раундов
miral(n, r/b)
	*** @+L1(20)
	*** @+L2(20)
	*** @+L3(20)
	*** OQ1=Q2 ***=Q3
	n-1=m Oq=s=b Dq
	*countZeroes(m/s) *** на этой строке считается s - степень двойки (2^s)*t+1
	q<s=q m/q=t
	*** /'q = '>C *printf(q/) /'\n'>C
	*** /'s = '>C *printf(s/) /'\n'>C
	*** /'t = '>C *printf(t/) /'\n'>C
	Oi=j=a
	P1 ?(i>=r)4 a+2=a
		 *** m-1=a X;a=a ?(a<2)1 *** поиск псевдослучайного значения от 2 до n-2
		 *** /'i = '>C *printf(i/) /'\n'>C
		 *** /'a = '>C *printf(a/) /'\n'>C
		 *pow(a, t, n/x) Di
		 ?(x=1)1 1=j ?(x=m)1
	P2 ?(j>=s)3
		 *** x=L1.0 n=L2.0 1=Q1=Q2
		 *** /'x = '>C *printf(x/) /'\n'>C
		 *** /'m = '>C *printf(m/) /'\n'>C
		 *pow(x, 2, n/x)
		 *** L1*L1;L2=L1 L1.0=x
		 ?(x=1)3 Dj ?(x=m)4 ?=2
	P3 ?=5 *** /'Составное\n'>C ?=5
	P4 Db *** /'Вероятно простое\n'>C
	P5
**




*** проверка, что 2 больших числа равны
*** BN_eq(L1, L2/b)

*** проверка, что большое число L1 больше числа L2
*** BN_gr(L1, L2/b)

*** проверка, что большое число L1 меньше числа L2
*** BN_less(L1, L2/b)

*** проверка, что большое число L1 больше ил равно числу L2
*** BN_greq(L1, L2/b)

*** проверка, что большое число L1 меньше или равно числу L2
*** BN_leq(L1, L2/b)

*** проверка, что 2 больших числа не равны
*** BN_neq(L1, L2/b)
