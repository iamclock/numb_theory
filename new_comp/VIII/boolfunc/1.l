main(/)
	
	
	
	*** *bool_input_output_weight_test(/)
	*** *bool_rand_test(/)
	*** *bool_moebius_test(/)
	*** *bool_pua_test(/)
	*test_printANF(/)
**

***********************************************************************************************
*****************************************  Алгоритмы  *****************************************
***********************************************************************************************

*** тестирование функции преобразования уолша-адамара
bool_pua_test(/)
	@+L1(10000000)
	28=n In+10=t
	@+L3(t)
	@+F2(100)
	*** 32=L1.0
	*** OQ2 @'0101'>F2
	*** OQ2 @'0011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'10010101'>F2
	*** OQ2 @'11111111'>F2
	*** OQ2 @'0001000100011110'>F2
	*** OQ2 @'10100100'>F2
	*** OQ2 @'11000011'>F2
	*** OQ2 @'11000000'>F2
	*** OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'01100000'>F2
	*** OQ2 @'01110111'>F2
	*** *BFinput(F2/L1)
	/'t = '>C *printf(t/) /'\n'>C
	*BFrand(L1, n/L1) /'ok\n'>C
	*** *BFoutput_string(L1/) /'\n'>C /'\n'>C
	*pua(L1/L3)
	*** *sprint_complex(L3/) /'\n'>C
	
	
**



*** превращение булева вектора в характеристический вектор
toCharactVect(L1/L2)
	Oi=j+1=l
	P1
		Ij&L1l>j+2;3-1=L2i Di Dj ?(j>31)2 ?=1
	P2
		Oj Dl ?(l<Q1)1
**


*** преобразование уолша-адамара
*** 
***  a   b   c   d
*** a+b a-b c+d c-d
***  e   f   g   h
*** e+g f+h e-g f-h
*** b - граница
pua(L1/L2)
	L1.0=n In=Q2 Op=j=k 1=i=s In-1=n/2+1=m  *** 1<L1.0-1=n/2+1=m
	*toCharactVect(L1/L2)
	/'n = '>C *printf(n/) /'\n'>C
	*** *sprint_complex(L2/) /'\n'>C
	P97
		 Ik=s Op=j ?(s>m)100 Dk
		P98
			L2j=a j+s=l L2l=b *** /'22\n'>C
			*** /'a = '>C *sprintf(a/) /'\n'>C
			*** /'b = '>C *sprintf(b/) /'\n'>C
			a+b=L2j a-b=L2l *** /'33\n'>C
			*** /'	j = '>C *printf(j/) /'\n'>C
			*** /'	l = '>C *printf(l/) /'\n'>C
			*** /'	p = '>C *printf(p/) /'\n'>C
			*** /'	s = '>C *printf(s/) /'\n'>C
			*** /'	m = '>C *printf(m/) /'\n'>C
			Dj Dp ?(l>=n)97 ?(p>=s)99
			*** /'s = '>C *sprintf(s/) /'\n'>C
			*** /'j = '>C *sprintf(s/) /'\n'>C
			*** /'l = '>C *sprintf(s/) /'\n'>C
			?=98
			*** ?=100
	P99
		j+s=j Op ?=98
	P100 *** /'qq\n'>C
		*** /'Q2 = '>C *printf(Q2/) /'\n'>C
**



*** /'a = '>C *printf(a/) /'\n'>C
*** /'b = '>C *printf(b/) /'\n'>C
*** /'c = '>C *printf(c/) /'\n'>C
*** /'d = '>C *printf(d/) /'\n'>C
*** ffffffffh=t /'t = '>C *sprintf(t/) /'\n'>C
*** 0-1=t /'t = '>C *printf(t/) /'\n'>C
*** /'L3l = '>C *sprintf(L3l/) /'\n'>C


*** тестирование функции преобразования Мёбиуса
bool_moebius_test(/)
	@+L1(100)
	@+L3(100)
	@+F2(100)
	*** 32=L1.0
	*** OQ2 @'01010011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	*** OQ2 @'01010101010101010101010101010101'>F2
	*** OQ2 @'0001000100011110'>F2
	 OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'00000000000000001111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0000000000000000000000000000000011111111111111111111111111111111'>F2
	*** OQ2 @'00000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** *printf(Q2/) /'\n'>C
	*** /F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C /'\n'>C
	*** *moebiusTransform_mod(L1/L3)
	*mobiusTransform(L1/L3)
	
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L3/) /'\n'>C /'\n'>C
	*** *BFoutput(L3/) /'\n'>C
	
	*** *moebiusTransform_mod(L3/L1)
	*mobiusTransform(L3/L3)
	*BFoutput_string(L3/) /'\n'>C /'\n'>C
	*** *BFoutput(L1/) /'\n'>C
	
	
**


*** Функция преобразование мобиуса для булева вектора
***
*** b - граница
***
mobiusTransform(L1/L2)
	@+L3(100)
	*** /'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	Q1=Q2-1/2=n L1.0=L2.0 1=i=l Os *** <L1.0=k
	*** *printf(Q1/) /'\n'>C
	*** /'n = '>C *printf(n/) /'\n'>C
	P1
		L1i=g
		*** /'g = '>C *printf(g/) /'\n'>C
		g<1&aaaaaaaah^g=g
		g<2&cccccccch^g=g
		g<4&f0f0f0f0h^g=g
		g<8&ff00ff00h^g=g
		g<16&ffff0000h^g=L2i Di ?(i<Q1)1
	P2
		1=i 1<s=l ?(l>n)5 Ds Ob
		P3
			i+l=j Db ?(j>Q2)2 ?(b>l)4 L2i^L2j=L2j Di ?=3
			*** /'i = '>C *printf(i/) /'\n'>C
		P4
			Ob i+l=i ?=3
	P5
**




*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1/L2)
	OQ2 ?(Q1<1)6
	Q1=s-1&s?+6 *** проверка длины входных значений
	Oj=i=z
	*** задаётся размер комплекса
	*** число функций делится на 32 и добавляется ещё 2 элемента 1 под количество переменных один резервный, который в конце отбрасывается, если не понадобится
	Q1=n>5+2=Q2-1=t OL2t
	P1 Di=L2.0 n>1=n?+1 ∇L2.0 Oi *** подсчёт переменных в функции
	*** /'Q2 = '>C *printf(Q2/)  /'\n'>C *** размер функции
	*** /'L2.0 = '>C *printf(L2.0/)  /'\n'>C *** количество переменных
	Dj OL2j
	P2 F1i-48?+3 L2j ?=4
	P3 1<z=t L2j|t=L2j
	P4 Dz Di ?(i=Q1)7 i;32?-5 ?=2
	P5 Dj Oz OL2j ?=2
	P6 /'Ошибка: Возможно пустой символьный комплекс или длина булевой функции\n'>C
	P7 Q2-1=l ?(L2l>0)8 l=Q2 *** *cutZerosBN(L2/L2)
		 *** *printf(L2.0/) /' '>C *printf(L2.1/) /' '>C *printf(L2.2/) /' '>C *printf(Q2/)  /'\n'>C
	P8
**


*** 
*** n - размер булевой функции
*** вывод булевой функции со значениями переменных
BFoutput(L1/)
	?(Q1<1)3
	Oi
	P1 ?(i>=L1.0)2 /' X'>C *printf(i/) /' '>C Di ?=1
	P2 /'| f \n'>C Oi
	P3 ?(i>=L1.0)4 /'----'>C Di ?=3
	P4 /'----\n'>C
	Oz=c 1=i 1<L1.0=n
	P5 0=j 1<L1.0>1=l 1<z=q L1i&q>z=t Dc
		 *** *printf(c/) /' '>C
		 P8
			?(j>=L1.0)9 L1.0-j-1=w c-1&l>w=w /' '>C *printf(w/) /'  '>C l>1=l Dj ?=8
		 P9
			/'| '>C *printf(t/) /' '>C
		 Dz ?(z=32)6 ?(c=n)7 /'\n'>C ?=5
	P6 Oz Di ?(i=Q1)7 /'\n'>C ?=5
	P7 *** /'\n'>C
**


*** 
*** n - размер булевой функции
*** вывод булевой функции строкой или в столбик
BFoutput_string(L1/)
	?(Q1<1)3
	Oz=c 1=i 1<L1.0=n
	P1 1<z=t L1i&t>z=t Dc
		 *** *printf(c/) /' '>C
		 *printf(t/) *** /'\n'>C
		 Dz ?(z=32)2 ?(c=n)3 ?=1
	P2 Oz Di ?(i=Q1)3 ?=1
	P3 *** /'\n'>C
**


BFweight(L1/n)
	?(Q1<1)2 Oi=n Di
	P1 L1i%+n=n Di ?(i<Q1)1
	P2
**


test_printANF(/)
	@+L1(100)
	@+F2(100)
	@+L3(100)
	*** 32=L1.0
	OQ2 @'01010011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	*** OQ2 @'01010101010101010101010101010101'>F2
	*** OQ2 @'0001000100011110'>F2
	*** OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'00000000000000001111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0000000000000000000000000000000011111111111111111111111111111111'>F2
	*** OQ2 @'00000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*BFinput(F2/L1)
	*BFoutput_string(L1/) /'\n'>C
	1<L1.0=t
	@+F4(100)
	*printANF(L1/F4)
	/F4>C /'\n'>C
	
**


copySymbComplex(F1, F2/F2)
	Oi S2-1=n ?(Q1<1)3
	P1
		F1i@>F2 Di ?(Q2>n)2 ?(i<Q1)1 ?=3
	P2
		/'copySymbComplex: Q2 больше чем его размерность\n'>C
	P3
**


printANF(L1/F2)
	Q1=n OQ2
	@+L3(n)
	@+F4(10)
	*mobiusTransform(L1/L3)
	*BFoutput_string(L3/) /'\n'>C
	L3.0-1=n Q3-1=m 1=i Of
	P91
		Os ?(L3i=0)93 *** s=0 - начинаю с начала
	P92
		?(s>31)93 L3.0=t ?(s>It)93 ?(f=0)96 Of @' + '>F2
	P96
		*** /'s = '>C *printf(s/) /'\n'>C
		L3i&Is=t
		*** /'t = '>C *printf(t/) /'\n'>C
		Ds ?(t=0)92
		Oj s-1=k
	P94
		1=f ?(j>n)92
		*** /'i = '>C *printf(i/) /'\n'>C
		/'k = '>C *printf(k/) /'\n'>C
		Ij&k=t Dj
		*** /'t = '>C *printf(t/) /'\n'>C
		?(t>0)95 ?=94
	P93
		Di ?(i<m)91 ?=100
	P95
		'X'@>F2 i-1=c c*32+n-j+2=t *** /'qq\n'>C
		/'j = '>C *printf(j/) /'\n'>C
		/'t = '>C *printf(t/) /'\n'>C
		OQ4 *n2s(t, 10/F4) *copySymbComplex(F4, F2/F2)
		*** /F2>C /'\n'>C
		?=94 *** ?(j<=n)94 ?=94
	P100
		Q2-3=Q2
**



*** BFrand(L1/)


*** генерация булевой функции от n переменных
*** n - количество переменных
*** s - шаг, идёт до размера булевой функции
*** L1 - булева функция
*** i - текущий элемент из L1
*** величина сдвига
BFrand(L1, n/L1)
	Oc=j 1=i n=L1.0
	1<n=t>5+2=Q1-1=l OL1l
	*** /'n = '>C *printf(n/) /'\n'>C
	*** /'t = '>C *printf(t/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*** /'L1.0 = '>C *printf(L1.0/) /'\n'>C
	16=s ?(L1.0>3)2 t;32=s *** c;t?-3 вместо ?(c>=t)3 ?
	P2 X>s=L1i c+s=c ?(c>=t)3 X>s<s|L1i=L1i c+s=c ?(c>=t)3 Di OL1i ?=2
	P3 *cutZerosBN(L1/L1) *** /'s = '>C *printf(s/) /'\n'>C
	*** *printf(L1.3/) /'\n'>C
	*** нужен ли cutZerosBN ?
**

***********************************************************************************************
*******************************************  Тесты  *******************************************
***********************************************************************************************


*** сделать генератор
*** сделать алгоритм Мёбиуса
*** сделать цивилизованный вывод
*** нужно ли добавлять cutZerosBN ?
*** c;t-3 вместо ?(c>=t)3 ?


*** тестирование функций ввода/вывода, подсчёта размера булевой функции
bool_input_output_weight_test(/)
	@+L1(100)
	@+F2(100)
	*** 32=L1.0
	OQ2
	@'0111010110101010101010101010100101010101010101010101010101101101110111001001001101110101101010101010101010101001010101010101010101110101101010101010101010101001010101010101010101010101011011011101110010010011011101011010101010101010101010010101010101010101'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
**




*** тестирование функции генератора булевой функции
bool_rand_test(/)
	@+L1(100)
	
	X X;10=t
	4=t
	*** /'main t = '>C *printf(t/) /'\n'>C
	*BFrand(L1, t/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	
**




