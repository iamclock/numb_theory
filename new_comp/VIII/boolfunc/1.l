main(/)
	
	
	
	*bool_input_output_weight_test(/)
	*** *bool_rand_test(/)
	
**


*** сделать генератор
*** сделать алгоритм Мёбиуса


*** тестирование функций ввода/вывода, подсчёта размера булевой функции
bool_input_output_weight_test(/)
	@+L1(100)
	@+F2(100)
	*** 32=L1.0
	OQ2
	@'0111010110101010101010101010100101010101010101010101010101101101110111001001001101110101101010101010101010101001010101010101010101110101101010101010101010101001010101010101010101010101011011011101110010010011011101011010101010101010101010010101010101010101'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
**




*** тестирование функции генератора булевой функции
bool_rand_test(/)
	@+L1(100)
	
	X X;10=t
	*BFrand(L1, t/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/)
	
**

*** тестирование функции преобразования Мёбиуса
bool_moebius_test(/)
	
	
	
	
	
**


*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1/L2)
	OQ2 ?(Q1<1)6
	Q1=s-1&s?+6 *** проверка длины входных значений
	Oj=i=z
	*** задаётся размер комплекса
	*** число функций делится на 32 и добавляется ещё 2 элемента 1 под количество переменных один резервный, который в конце отбрасывается, если не понадобится
	Q1=n>5+2=Q2-1=t OL2t
	P1 Di=L2.0 n>1=n?+1 ∇L2.0 Oi *** подсчёт переменных в функции
	*** /'Q2 = '>C *printf(Q2/)  /'\n'>C *** размер функции
	*** /'L2.0 = '>C *printf(L2.0/)  /'\n'>C *** количество переменных
	Dj OL2j
	P2 F1i-48?+3 L2j ?=4
	P3 1<z=t L2j|t=L2j
	P4 Dz Di ?(i=Q1)7 i;32?-5 ?=2
	P5 Dj Oz OL2j ?=2
	P6 /'Ошибка: Возможно пустой символьный комплекс или длина булевой функции\n'>C
	P7 *cutZerosBN(L2/L2)
		 *** *printf(L2.0/) /' '>C *printf(L2.1/) /' '>C *printf(L2.2/) /' '>C *printf(Q2/)  /'\n'>C
**

*** 
*** n - размер булевой функции
*** вывод булевой функции
BFoutput(L1/)
	?(Q1<1)3
	Oz=c 1=i 1<L1.0=n
	P1 1<z=t L1i&t>z=t Dc
		 *** *printf(c/) /' '>C
		 *printf(t/) *** /'\n'>C
		 Dz ?(z=32)2 ?(c=n)3 ?=1
	P2 Oz Di ?(i=Q1)3 ?=1
	P3 *** /'\n'>C
**


BFweight(L1/n)
	?(Q1<1)2 Oi=n Di
	P1 L1i%+n=n Di ?(i<Q1)1
	P2
**


*** BFrand(L1/)


*** генерация булевой функции от n переменных
*** s - шаг, идёт до размера булевой функции (L1.0)
*** L1 - булева функция
*** i - текущий элемент из L1
BFrand(L1, n/L1)
	Ox=s=j 1=i
	*** /'n = '>C *printf(n/) /'\n'>C
	1<n=L1.0>5+1=Q1
	*printf(Q1/) /'\n'>C
	*printf(L1.0/) /'\n'>C
	*** /'размер булевой функции = '>C *printf(L1.0/) /'\n'>C
	P1 X>16<16=L1i s+16=s ?(s>=L1.0)3 X>16|L1i=L1i ?(s>=L1.0)3 s+16=s Di i+1=Q1 OL1i ?=1
	P3 *printf(Q1/) /'\n'>C
	*** /'L1i = '>C *printf(L1.3/) /'\n'>C
**

