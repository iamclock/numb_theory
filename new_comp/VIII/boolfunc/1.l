main(/)
	
	
	
	*** *bool_input_output_weight_test(/)
	*** *bool_rand_test(/)
	*bool_moebius_test(/)
**

***********************************************************************************************
*****************************************  Алгоритмы  *****************************************
***********************************************************************************************


*** тестирование функции преобразования Мёбиуса
moebiusTransform(L1/L2)
	@+L3(100)
	L1=L3 1=i=s Or=q
	P1
		Oy q;32=q
		*** y = a
		L3i&s=x|y=y *** /'y = '>C *printf(s/) /'\n'>C
		*** y = a,a^b
		s<1=s&L3i=a^x|y=y *** /'y = '>C *printf(y/) /'\n'>C /'a = '>C *printf(a/) /'\n'>C
		*** y = a,a^b,a^c
		s<1=s&L3i=c^x|y=y *** /'y = '>C *printf(y/) /'\n'>C
		/'c = '>C *printf(c/) /'\n'>C
		*** y = a,a^b,a^c,c^d^a^b
		q+1=w
		/'w = '>C *printf(w/) /'\n'>C
		1<w&L3i=w s<1=s&L3i=d^c^w|y=y
	/'s = '>C *printf(s/) /'\n'>C
	/'w = '>C *printf(w/) /'\n'>C
	/'d = '>C *printf(d/) /'\n'>C
	/'c = '>C *printf(c/) /'\n'>C
	/'y = '>C *printf(y/) /'\n'>C
	
	
**




*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1/L2)
	OQ2 ?(Q1<1)6
	Q1=s-1&s?+6 *** проверка длины входных значений
	Oj=i=z
	*** задаётся размер комплекса
	*** число функций делится на 32 и добавляется ещё 2 элемента 1 под количество переменных один резервный, который в конце отбрасывается, если не понадобится
	Q1=n>5+2=Q2-1=t OL2t
	P1 Di=L2.0 n>1=n?+1 ∇L2.0 Oi *** подсчёт переменных в функции
	*** /'Q2 = '>C *printf(Q2/)  /'\n'>C *** размер функции
	*** /'L2.0 = '>C *printf(L2.0/)  /'\n'>C *** количество переменных
	Dj OL2j
	P2 F1i-48?+3 L2j ?=4
	P3 1<z=t L2j|t=L2j
	P4 Dz Di ?(i=Q1)7 i;32?-5 ?=2
	P5 Dj Oz OL2j ?=2
	P6 /'Ошибка: Возможно пустой символьный комплекс или длина булевой функции\n'>C
	P7 Q2-1=l ?(L2l>0)8 l=Q2 *** *cutZerosBN(L2/L2)
		 *** *printf(L2.0/) /' '>C *printf(L2.1/) /' '>C *printf(L2.2/) /' '>C *printf(Q2/)  /'\n'>C
	P8
**


*** 
*** n - размер булевой функции
*** вывод булевой функции со значениями переменных
BFoutput(L1/)
	?(Q1<1)3
	Oi
	P1 ?(i>=L1.0)2 /' X'>C *printf(i/) /' '>C Di ?=1
	P2 /'| f \n'>C Oi
	P3 ?(i>=L1.0)4 /'----'>C Di ?=3
	P4 /'----\n'>C
	Oz=c 1=i 1<L1.0=n
	P5 0=j 1<L1.0>1=l 1<z=q L1i&q>z=t Dc
		 *** *printf(c/) /' '>C
		 P8
			?(j>=L1.0)9 L1.0-j-1=w c-1&l>w=w /' '>C *printf(w/) /'  '>C l>1=l Dj ?=8
		 P9
			/'| '>C *printf(t/) /' '>C
		 Dz ?(z=32)6 ?(c=n)7 /'\n'>C ?=5
	P6 Oz Di ?(i=Q1)7 /'\n'>C ?=5
	P7 *** /'\n'>C
**


*** 
*** n - размер булевой функции
*** вывод булевой функции строкой или в столбик
string_BFoutput(L1/)
	?(Q1<1)3
	Oz=c 1=i 1<L1.0=n
	P1 1<z=t L1i&t>z=t Dc
		 *** *printf(c/) /' '>C
		 *printf(t/) *** /'\n'>C
		 Dz ?(z=32)2 ?(c=n)3 ?=1
	P2 Oz Di ?(i=Q1)3 ?=1
	P3 *** /'\n'>C
**


BFweight(L1/n)
	?(Q1<1)2 Oi=n Di
	P1 L1i%+n=n Di ?(i<Q1)1
	P2
**


*** BFrand(L1/)


*** генерация булевой функции от n переменных
*** n - количество переменных
*** s - шаг, идёт до размера булевой функции
*** L1 - булева функция
*** i - текущий элемент из L1
*** величина сдвига
BFrand(L1, n/L1)
	Oc=j 1=i n=L1.0
	1<n=t>5+2=Q1-1=l OL1l
	*** /'n = '>C *printf(n/) /'\n'>C
	*** /'t = '>C *printf(t/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*** /'L1.0 = '>C *printf(L1.0/) /'\n'>C
	16=s ?(L1.0>3)2 t;32=s *** c;t?-3 вместо ?(c>=t)3 ?
	P2 X>s=L1i c+s=c ?(c>=t)3 X>s<s|L1i=L1i c+s=c ?(c>=t)3 Di OL1i ?=2
	P3 *cutZerosBN(L1/L1) /'s = '>C *printf(s/) /'\n'>C
	*printf(L1.3/) /'\n'>C
	*** нужен ли cutZerosBN ?
**

***********************************************************************************************
*******************************************  Тесты  *******************************************
***********************************************************************************************


*** сделать генератор
*** сделать алгоритм Мёбиуса
*** сделать цивилизованный вывод
*** нужно ли добавлять cutZerosBN ?
*** c;t-3 вместо ?(c>=t)3 ?


*** тестирование функций ввода/вывода, подсчёта размера булевой функции
bool_input_output_weight_test(/)
	@+L1(100)
	@+F2(100)
	*** 32=L1.0
	OQ2
	@'0111010110101010101010101010100101010101010101010101010101101101110111001001001101110101101010101010101010101001010101010101010101110101101010101010101010101001010101010101010101010101011011011101110010010011011101011010101010101010101010010101010101010101'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
**




*** тестирование функции генератора булевой функции
bool_rand_test(/)
	@+L1(100)
	
	X X;10=t
	4=t
	*** /'main t = '>C *printf(t/) /'\n'>C
	*BFrand(L1, t/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	
**

*** тестирование функции преобразования Мёбиуса
bool_moebius_test(/)
	@+L1(100)
	@+L2(100)
	@+F2(100)
	*** 32=L1.0
	OQ2 @'01010011'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*moebiusTransform(L1/L2)
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
	
	
	
**


