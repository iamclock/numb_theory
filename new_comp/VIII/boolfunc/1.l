main(/)
	
	
	
	*** *bool_input_output_weight_test(/)
	*** *bool_rand_test(/)
	*** *bool_moebius_test(/)
	*bool_pua_test(/)
**

***********************************************************************************************
*****************************************  Алгоритмы  *****************************************
***********************************************************************************************

*** тестирование функции преобразования уолша-адамара
bool_pua_test(/)
	@+L1(100)
	@+L3(512)
	@+F2(100)
	*** 32=L1.0
	OQ2 @'0101'>F2
	*** OQ2 @'0011'>F2
	*BFinput(F2/L1)
	*pua(L1/L3)
	*print_complex(L3/) /'\n'>C
	
	
**


*** преобразование уолша-адамара
*** 
*** 
*** 
*** Идея: брать числа по модулю 5, тогда 3 и 4 = -2 и -1
*** но, если a+b=2, c+d=2 => e+i=4, что не равно -1
*** что делать в таком случае
*** 
pua(L1/L2)
	1<L1.0=n
	@+L3(n) ***(512)
	n=Q3 Oj=l 1=i
	
	P1
		4*j=t
		L1i<t&1h=a L1i<t&2h>1=b
		L1i<t&4h>2=c L1i<t&8h>3=d
		/'a = '>C *printf(a/) /'\n'>C
		/'b = '>C *printf(b/) /'\n'>C
		/'c = '>C *printf(c/) /'\n'>C
		/'d = '>C *printf(d/) /'\n'>C
		a+b=t a+5-b;5=b t=a
		c+d=t c+5-d;5=d t=c
		a+c=L3l Dl b+d;5=L3l Dl
		a+5-c;5=L3l Dl b+5-d;5=L3l Dl
		Dj
		/'l = '>C *printf(l/) /'\n'>C
		?(l>=n)3 ?(j>=8)2 ?=1
	P2
		Di Oj ?(i>=Q1)3 ?=1
	P3
		L3=L2
**

*** тестирование функции преобразования Мёбиуса
bool_moebius_test(/)
	@+L1(100)
	@+L3(100)
	@+F2(100)
	*** 32=L1.0
	*** OQ2 @'01010011'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** *printf(Q2/) /'\n'>C
	*** /F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*** *moebiusTransform_mod(L1/L3)
	*MT(L1/L3)
	
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L3/) /'\n'>C
	*** *BFoutput(L3/) /'\n'>C
	
	*** *moebiusTransform_mod(L3/L1)
	*MT(L1/L3)
	*BFoutput_string(L1/) /'\n'>C
	*** *BFoutput(L1/) /'\n'>C
	
	
**

MT(L1/L2)
	@+L3(100)
	*** /'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	Q1=Q2 L1.0=L2.0
	*** /'n = '>C *printf(n/) /'\n'>C
	P1
		L1i=g
		g<1&aaaaaaaah^g=g
		g<2&cccccccch^g=g
		g<4&f0f0f0f0h^g=g
		g<8&00ff00ffh^g=g
		g<16&0000ffffh^g=L2i
	P2
		i=j Di ?(i>=Q1)3 L1i^L2j=L2i ?=2
	P3
**


*** функция преобразование Мёбиуса
*** r - результат вычислений
*** z - подготовительный результат, результат - один элемент комплекса
*** q - триггер для перехода в преобразование второй половины 8 битов
*** y - преобразованная половина 8 битов
*** L3 - результат
*** a b c d e f g h
*** a
*** a^b
*** a^c
*** (a^b)^(c^d)
*** (a^e)
*** (a^b)^(e^f)
*** (a^c)^(e^g)
*** (a^b)^(c^d)^(e^f)^(i^h)
moebiusTransform(L1/L2)
	@+L3(100)
	*** /'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	Q1=Q3 L1.0=L3.0 1<L1.0-1=n 1=i Or=q=j
	Oa=b=c=d=z
	*** /'n = '>C *printf(n/) /'\n'>C
	P1
		1<j&L1i=e|z=z Dj
		*** z = a,a^b
		e<1=x 1<j&L1i=f^x=f|z=z Dj
		*** z = a,a^b,a^c
		x<1=x 1<j&L1i=g^x=x|z=z Dj
		*** z = a,a^b,a^c,c^d^a^b
		g<1=g f<2=f
		1<j&L1i^g^f=h|z=z Dq Dj
	?(q=2)3 j=l e<4=a f<2=b x<4=c h<4=d z=L3i ?(j>n)4 ?(j>31)2 ?=1
	P2
		z=L3i Di ?(i>=Q1)4 Oj=z=r ?=1
	P3
		Oy
		*** a<4=a b<2=b c<4=c d<4=d
		1<l&z=e^a=x|y=y Dl
		1<l&z^b=x|y=y Dl
		1<l&z^c=x|y=y Dl
		1<l&z^d=x|y=y Dl
		j-8=t
		fh<t&z=t y|t|r=r=z
		Oq z=L3i ?(j>n)4 ?(j>31)2 ?=1
	P4
		L3=L2
**


moebiusTransform_mod(L1/L2)
	@+L3(100)
	*** /'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	Q1=Q3 L1.0=L3.0 1<L1.0-1=n 1=i Or=q=j
	Oa=b=c=d=z
	*** /'n = '>C *printf(n/) /'\n'>C
	P1
		1<j&L1i=e|z=z Dj
		*** z = a,a^b
		e<1=x 1<j&L1i=f^x=f|z=z Dj
		*** z = a,a^b,a^c
		x<1=x 1<j&L1i=g^x=x|z=z Dj
		*** z = a,a^b,a^c,c^d^a^b
		g<1=g f<2=f
		1<j&L1i^g^f=h|z=z Dq Dj
	?(q=2)3 j=l e<4=a f<2=b x<4=c h<4=d z=L3i ?(j>n)4 ?(j>31)2 ?=1
	P2
		z=L3i Di ?(i>=Q1)4 Oj=z=r ?=1
	P3
		Oy
		*** a<4=a b<2=b c<4=c d<4=d
		1<l&z=e^a=x|y=y Dl
		1<l&z^b=x|y=y Dl
		1<l&z^c=x|y=y Dl
		1<l&z^d=x|y=y Dl
		j-8=t
		fh<t&z=t y|t|r=r=z
		Oq z=L3i ?(j>n)4 ?(j>31)2 ?=1
	P4
		L3=L2
**



*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1/L2)
	OQ2 ?(Q1<1)6
	Q1=s-1&s?+6 *** проверка длины входных значений
	Oj=i=z
	*** задаётся размер комплекса
	*** число функций делится на 32 и добавляется ещё 2 элемента 1 под количество переменных один резервный, который в конце отбрасывается, если не понадобится
	Q1=n>5+2=Q2-1=t OL2t
	P1 Di=L2.0 n>1=n?+1 ∇L2.0 Oi *** подсчёт переменных в функции
	*** /'Q2 = '>C *printf(Q2/)  /'\n'>C *** размер функции
	*** /'L2.0 = '>C *printf(L2.0/)  /'\n'>C *** количество переменных
	Dj OL2j
	P2 F1i-48?+3 L2j ?=4
	P3 1<z=t L2j|t=L2j
	P4 Dz Di ?(i=Q1)7 i;32?-5 ?=2
	P5 Dj Oz OL2j ?=2
	P6 /'Ошибка: Возможно пустой символьный комплекс или длина булевой функции\n'>C
	P7 Q2-1=l ?(L2l>0)8 l=Q2 *** *cutZerosBN(L2/L2)
		 *** *printf(L2.0/) /' '>C *printf(L2.1/) /' '>C *printf(L2.2/) /' '>C *printf(Q2/)  /'\n'>C
	P8
**


*** 
*** n - размер булевой функции
*** вывод булевой функции со значениями переменных
BFoutput(L1/)
	?(Q1<1)3
	Oi
	P1 ?(i>=L1.0)2 /' X'>C *printf(i/) /' '>C Di ?=1
	P2 /'| f \n'>C Oi
	P3 ?(i>=L1.0)4 /'----'>C Di ?=3
	P4 /'----\n'>C
	Oz=c 1=i 1<L1.0=n
	P5 0=j 1<L1.0>1=l 1<z=q L1i&q>z=t Dc
		 *** *printf(c/) /' '>C
		 P8
			?(j>=L1.0)9 L1.0-j-1=w c-1&l>w=w /' '>C *printf(w/) /'  '>C l>1=l Dj ?=8
		 P9
			/'| '>C *printf(t/) /' '>C
		 Dz ?(z=32)6 ?(c=n)7 /'\n'>C ?=5
	P6 Oz Di ?(i=Q1)7 /'\n'>C ?=5
	P7 *** /'\n'>C
**


*** 
*** n - размер булевой функции
*** вывод булевой функции строкой или в столбик
BFoutput_string(L1/)
	?(Q1<1)3
	Oz=c 1=i 1<L1.0=n
	P1 1<z=t L1i&t>z=t Dc
		 *** *printf(c/) /' '>C
		 *printf(t/) *** /'\n'>C
		 Dz ?(z=32)2 ?(c=n)3 ?=1
	P2 Oz Di ?(i=Q1)3 ?=1
	P3 *** /'\n'>C
**


BFweight(L1/n)
	?(Q1<1)2 Oi=n Di
	P1 L1i%+n=n Di ?(i<Q1)1
	P2
**


*** BFrand(L1/)


*** генерация булевой функции от n переменных
*** n - количество переменных
*** s - шаг, идёт до размера булевой функции
*** L1 - булева функция
*** i - текущий элемент из L1
*** величина сдвига
BFrand(L1, n/L1)
	Oc=j 1=i n=L1.0
	1<n=t>5+2=Q1-1=l OL1l
	*** /'n = '>C *printf(n/) /'\n'>C
	*** /'t = '>C *printf(t/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*** /'L1.0 = '>C *printf(L1.0/) /'\n'>C
	16=s ?(L1.0>3)2 t;32=s *** c;t?-3 вместо ?(c>=t)3 ?
	P2 X>s=L1i c+s=c ?(c>=t)3 X>s<s|L1i=L1i c+s=c ?(c>=t)3 Di OL1i ?=2
	P3 *cutZerosBN(L1/L1) /'s = '>C *printf(s/) /'\n'>C
	*printf(L1.3/) /'\n'>C
	*** нужен ли cutZerosBN ?
**

***********************************************************************************************
*******************************************  Тесты  *******************************************
***********************************************************************************************


*** сделать генератор
*** сделать алгоритм Мёбиуса
*** сделать цивилизованный вывод
*** нужно ли добавлять cutZerosBN ?
*** c;t-3 вместо ?(c>=t)3 ?


*** тестирование функций ввода/вывода, подсчёта размера булевой функции
bool_input_output_weight_test(/)
	@+L1(100)
	@+F2(100)
	*** 32=L1.0
	OQ2
	@'0111010110101010101010101010100101010101010101010101010101101101110111001001001101110101101010101010101010101001010101010101010101110101101010101010101010101001010101010101010101010101011011011101110010010011011101011010101010101010101010010101010101010101'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
**




*** тестирование функции генератора булевой функции
bool_rand_test(/)
	@+L1(100)
	
	X X;10=t
	4=t
	*** /'main t = '>C *printf(t/) /'\n'>C
	*BFrand(L1, t/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	
**




