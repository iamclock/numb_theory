


n(a/b) 
	a+'A'⇒b ↑(a<10)1 a-10+'A'⇒b
	§1	**

n2c(a/b) 
	a+'0'⇒b ↑(a<10)1 a-10+'A'⇒b 
	§1	** 


s2n(F1,q/a)
   Oi
   §1 ↑(i≥Q1)2
      F1i⇒c
      *c2n(c/b)
      a*q+b⇒a
      ∆i →1
   §2 
**


decstrtoperem(F1/a)
 Oi
 F1i-'0'⇒a
 §1 ∆i ↑(i=Q1)3
 §2 a*10+F1i-'0'⇒a →1
 §3 **


genm(n,m/L1)
 32-n⇒k
 T;100⇒s
 Oj
 Oi
 §5 Oa
 §6 X ∆a
 §7 ↑(a<s)6
 §1 X>k⇒L1i ∆i ↑(i<m)5
 §3 m⇒Q1 **


 
 
scanf(F1, i, q/a, i)
	***↑(Q1=0)5
	Oa 10⇒q
	↑(i≥Q1)5
	§1 ↑(i≥Q1)4	*** может быть ошибка
  		F1i⇒c
  		↑(c≠' ')2 ∆i →4
  §2
      *c2n(c/b) ***/'b='>C *printf(b/) /'\n'>C
      *** /'q='>C *printf(q/) /'\n'>C
      a*q+b⇒a  ***/'a='>C *printf(a/) /'\n'>C
      ∆i →1
	§5	/'ERROR: Пустой массив(scanf)\n'>C
  §4
**
 


printf(k/)
	@+F1(100)
	OQ1
	*n2s(k,10/F1)
	/F1>C
	**





print_hex(a/)
	@+F1(100)
	Oi 15⇒y Of
	§1 ↑(i≥8)4
			i+1*4⇒s
			16<1-s⇒s *** *printf(s/) /'\n'>C
			a>s⇒x x&y⇒x *** *printf(x/) /'\n'>C
			↑(x=0)2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'@>F1 →1
	§3 ∆i ↑(f=0)1 x+'0'@>F1 →1
	§4 /F1>C /'\n'>C **





n2s(a,q/F1)
	§1 a;q⇒b a/q⇒a b+'0'⇒c ↑(b<10)2 'A'+b-10@>F1 →3
	§2 c@>F1
	§3 a↦1 *pervec(F1/F1) **


c2n(a/b)
   §1 a-'0'⇒b
      ↑(b<10)2
      a-'A'+10⇒b
      ↑(a<'Z')2
      a-'a'+10⇒b
   §2 
**




*** Дихотомический алг-тм возведения в степень числа
*** x - число возводимое в степень, y - степень этого числа, m - модуль
dihotom(x, y, m/z)
	x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i ↑(i>y)5 q*q;m⇒q *** *printf(q/) /'\n'>C
		 i&y↪3 z*q;m⇒z *** *printf(z/) /'\n'>C
		 →3
	§5 **



dihotom2(x, y/z)
	x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i ↑(i>y)5 q*q⇒q *** *printf(q/) /'\n'>C
		 i&y↪3 z*q⇒z *** *printf(z/) /'\n'>C
		 →3
	§5 **



pervec(F1/F1)
	Oi Q1-1⇒j
	§1 ↑(i≥j)2 F1i⇒t F1j⇒F1i t⇒F1j ∆i ∇j →1
	§2 **





*** на входе всегда нечётное число
*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
trial_division_method(n/L2)
	
	@+L1(4)
	3⇒L1.0 5⇒L1.1 7⇒L1.2 11⇒L1.3 4⇒Q1
	
	↑(n<2)6
	*** n;2⇒k ↑(k=0)4 *** k↪4 одно и тоже с ↑(k=0)4, но не работает
	Oi⇒j *** возможно придётся i присваивать 1
	§1 ↑(n=1)7
	§2 n;L1i⇒r n/L1i⇒q ↑(r≠0)4
	§3 L1i⇒L2j ∆j q⇒n →1
	§4 ↑(L1i≥q)5
		 ∆i ↑(i<Q1)2 Oi *recalc_efficients(L1/L1) →1 *** возможно придётся i присваивать 1
	§5
		 n⇒L2j ∆j →7
	§6 /'Число должно быть больше 1'>C
	§7 j⇒Q2
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method для маленьких чисел
recalc_efficients(L1/L1)
	Q1⇒t t-1⇒l t;2⇒t Oi L1l⇒l 4⇒d
	↑(t≠0)2
	§1 2⇒d
	§2 l+d⇒L1i⇒l ∆i d;4+2⇒d ↑(i<Q1)2 *** Oi
	§3 *** *printf(L1i/) /' '>C ∆i ↑(i<Q1)3 /'\n'>C
**








*** сделан не правильно
*** не должно быть делений или сведение их к минимуму, пересмотреть
*** основание системы счисления не передавать аргументом
barret_alg(x, m, b, z/r)
	↑(4>b)5 Ok⇒r m⇒t
	
	§1 ↑(t=0)2 t/b⇒t ∆k →1
	§2
	k-1⇒t
	*dihotom2(b, t/t)
	x/t*z⇒q k+1⇒p
	*dihotom2(b, p/t)
	q/p⇒q x;t⇒e q*m;t⇒w
	↑(e≥w)3 e-w⇒r →4
	§3 t+e-w⇒r
	§4 ↑(r<m)6 r-m⇒r →4
	§5 /'ERROR: Третий аргумент должен быть больше 3'>C /'\n'>C
	§6
**








div_mul_test(L1, L2/L3)
	@+L4(100)
	L1⇒L3⇒L4
	L1/L2 *** *print_big_hex(L4/)
	L4;L2 *** *print_big_hex(L3/)
	L1*L2+L4 *** *print_big_hex(L3/)
	**




big_int_rand(L1/)
	Q1⇒i X
	§1 i↪2 ∇i X⇒L1i →1
	§2 **








*** ввод большого числа [Добавить обработку нуля!!!]
*** k может вернуться больше размерности комплекса F1 => алгоритм не сработает, необходимо проверять в программе, что размер числа > 0
big_int_input(L2, F1, i/L2, k)
	Oj Ol Os
	*** первая проверка может быть лишняя из-за 8го парраграфа
	↑(Q1=0)6 ↑(i≥Q1)8
	*** /'i= '>C *printf(i/) /'\n'>C
	↑(F1i≠'0')7 ∆i ↑(F1i≠'x')7 ∆i⇒l⇒e
	*** /'e= '>C *printf(e/) /'\n'>C
	
	§10 ↑(l=Q1)11 ↑(F1l=' ')11 ↑(F1l=10)11 ∆l →10
	§11 l⇒k-1⇒i i-e+1/8⇒Q2 i-e+1;8⇒t ∆k Ol OL2l ↑(t=0)1 Q2+1⇒Q2
	§1
		↑(F1i<'0')7 ↑(F1i>'9')2 F1i-'0'⇒x →4
	§2
		↑(F1i<'A')7 ↑(F1i>'F')3 F1i-'A'+10⇒x →4
	§3
		↑(F1i<'a')7 ↑(F1i>'f')7 F1i-'a'+10⇒x
	§4
		x<s⇒x s+4⇒s L2l∨x⇒L2l ∇i ↑(i<e)9 ∆j ↑(j≥8)5 →1
	§5
		∆l OL2l⇒s⇒j →1
	§6
		/'ОШИБКА: Символьный комплекс пустой\n'>C →9
	§7
		/'ОШИБКА: Число не шестнадцатеричное\n'>C OQ2 →9
	§8
		/'ОШИБКА: Символьный комплекс закончился.\n'>C OQ2
	§9 **




*** вывод большого числа в шестнадцатеричном виде
print_big_hex(L1/)
	@+F2(100)
	↑(Q1=0)6
	Oi⇒f 4⇒s Q1-1⇒j 15⇒y '0'@>F2 'x'@>F2
	§1 ↑(i≥8)4
			***/'j= '>C *printf(j/) /'\n'>C
			16<1-s⇒t ***/'t= '>C *printf(t/) /'\n'>C	*** 16 для оптимизации под конкретную архитектуру
			L1j>t⇒x x&y⇒x s+4⇒s ***/'x= '>C *printf(x/) /'\n'>C
			*** *print_hex(L1j/)
			x↪2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'@>F2 →1
	§3 ∆i ↑(f=0)1 x+'0'@>F2 →1
	§4 ↑(j=0)5 4⇒s ∇j Oi →1 *** ↑(j≥Q1)5
	§5 /F2>C /'\n'>C
	§6 **






*** Дихотомический алг-тм возведения в небольшую степень большого числа
*** L1 - число возводимое в степень, y - степень этого числа, L2 - модуль
_dihotom_big_int(L1, y, L2/L2)
	@+L4(100)
	@+L5(100)
	@+L3(100)
	
	1⇒Q4⇒Q5⇒Q3 1⇒L3.0
	L1⇒L5 1⇒L4.0⇒i /'d L5= '>C *print_big_hex(L5/) y&1↪3 L1⇒L4 /'d L4= '>C *print_big_hex(L4/)
	§3 i<1⇒i ↑(i>y)5 Q5+Q5+1⇒Q3 L3*L5*L5;L2⇒L5 /'Q5= '>C *printf(Q5/) /'\n'>C i&y↪3 Q4+Q5+1⇒Q3 L3*L4*L5;L2⇒L4 /'d L4= '>C *print_big_hex(L4/) →3
	§5 L4⇒L2 **




main(/)
   @+F1(1000) @+F2(100)
   @'liblf.l'>F2  /F2>C /'\n'>C
   *fopen(F2,0/a)
   *peper(a/)
   *freadf(a,F1,0,150/b)
   *peper(b/)
   *fclose(a/) OQ2
   @'liblf.txt'>F2 /F2>C /'\n'>C
   *fopen(F2,1/a)
   *peper(a/)
   *fwritef(a,F1,0,150/b)
   *peper(b/)
   **
********************************************************************
*** работа с файлами
********************************************************************
*** Открытие файла
*** F1 - имя файла (в текущем каталоге)
*** r - режим открытия: 0 - чтение, 1 - запись, 2 - чтение/запись
*** n  - дескриптор файла (<0 при отказе)
********************************************************************
fopen(F1,r/n)
   0@>F1
   {mov eax,5}
   {mov ebx,[ebp+220]}
   {mov ecx,[ebp+72]}
   {int 80h}
   {mov [ebp+56],eax}
   **
********************************************************************
*** Закрытие файла
*** n  - дескриптор файла
********************************************************************
fclose(n/)
   {mov eax,6}
   {mov ebx,[ebp+56]}
   {int 80h}
   **
********************************************************************
*** Чтение из файла в символьный комплекс
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого считанного байта
*** l - число запрашиваемых байт
*** k - число считанных байтов (код ошибки для <0)
********************************************************************
freadf(n,F1,b,l/k)
   {mov eax,3}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **
********************************************************************
*** Запись из символьного комплекса в файл
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого записываемого байта
*** l - число записывемых байт
*** k - число записанных байтов (код ошибки для <0)
********************************************************************
fwritef(n,F1,b,l/k)
   {mov eax,4}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **

   
   
   
   
   
   
   
   
   
*** Ошибки:


matrixoutput(L1,m,n/) 
 @+F2(34)
 Oa
 §1 *binperemtostr(L1a,n/F2) ∆a
 §2 /F2>C /'\n'>C ↑(a<m)1 **



binstrtoperem(F1/x)
 Oi
 Ox
 Q1-1⇒j
*** Q1-1⇒i
 §1 ↑(F1i='0')2 x|Ij⇒x
 §2 ∇j ∆i ↑(i<Q1)1 **




out3(a,b,n/F1)
 OQ1
 n-1⇒i
 §1 a&Ii⇒x x↦2 '1'@>F1 ↑(i=0)3 ∇i →1
 §2 '0'@>F1 ↑(i=0)3 ∇i →1
 §3 /'a⇒ ' /F1>C /'\n'>C
 OQ1
 n-1⇒i
 §4 b&Ii⇒x x↦5 '0'@>F1 ↑(i=0)6 ∇i →1
 §5 '1'@>F1 ↑(i=0)6 ∇i →4
 §6 /'b⇒ ' /F1>C /'\n'>C **



*** вывод булевого вектора на экран
printbv(a, n/)
    31⇒i ∇n
 §1 ↑(i>n)3
    a&Ii ↪2 /' 1'>C →3
 §2 /' 0'>C
 §3 i↪4 ∇i →1
 §4 /'\n'>C **

*** вывод булевой матрицы на экран
printbm(L1,n/)
    Oi
 §1 *printbv(L1i,n/) ∆i ↑(i<Q1)1 /'\n'>C **
	

*** перевод числа в строку *** 

***************************************
numout(a/)
	@+F1(10)
	OQ1 
	§1	a/q⇒a Z⇒b *n(b/c) c@>F1 a↦1 
  §2	Oi Q1⇒a-1⇒j 
  §3	↑(i≥j)4  =(F1ij) ∆i ∇j →3 
  §4   ** 

 
 
binperemtostr(x,n/F1)
 OQ1
 n-1⇒i
 §1 x&Ii⇒a a↦2 '0'@>F1 ↑(i=0)3 ∇i →1
 §2 '1'@>F1 ↑(i=0)3 ∇i →1
 §3 **