


n(a/b) 
	a+'A'⇒b ↑(a<10)1 a-10+'A'⇒b
	§1
**

n2c(a/b) 
	a+'0'⇒b ↑(a<10)1 a-10+'A'⇒b 
	§1
** 


s2n(F1,q/a)
	Oi
	§1 ↑(i≥Q1)2
			F1i⇒c
			*c2n(c/b)
			a*q+b⇒a
			∆i →1
	§2 
**


decstrtoperem(F1/a)
	Oi
	F1i-'0'⇒a
	§1 ∆i ↑(i=Q1)3
	§2 a*10+F1i-'0'⇒a →1
	§3
**


genm(n,m/L1)
	32-n⇒k
	T;100⇒s
	Oj
	Oi
	§5 Oa
	§6 X ∆a
	§7 ↑(a<s)6
	§1 X>k⇒L1i ∆i ↑(i<m)5
	§3 m⇒Q1
**


 
 
scanf(F1, i, q/a, i)
	***↑(Q1=0)5
	Oa 10⇒q
	↑(i≥Q1)5
	§1 ↑(i≥Q1)4	*** может быть ошибка
  		F1i⇒c
  		↑(c≠' ')2 ∆i →4
  §2
      *c2n(c/b) ***/'b='>C *printf(b/) /'\n'>C
      *** /'q='>C *printf(q/) /'\n'>C
      a*q+b⇒a  ***/'a='>C *printf(a/) /'\n'>C
      ∆i →1
	§5	/'ERROR: Пустой массив(scanf)\n'>C
  §4
**
 


printf(k/)
	@+F1(100)
	OQ1
	*n2s(k,10/F1)
	/F1>C
**




Hprintf(a/)
	@+F1(100)
	@'0x'>F1
	Oi 15⇒y Of
	§1 ↑(i≥8)4
			i+1*4⇒s
			16<1-s⇒s *** *printf(s/) /'\n'>C
			a>s⇒x x&y⇒x *** *printf(x/) /'\n'>C
			↑(x=0)2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'@>F1 →1
	§3 ∆i ↑(f=0)1 x+'0'@>F1 →1
	§4 ↑(Q1=2)5 /F1>C
	§5
**





n2s(a,q/F1)
	§1 a;q⇒b a/q⇒a b+'0'⇒c ↑(b<10)2 'A'+b-10@>F1 →3
	§2 c@>F1
	§3 a↦1 *pervec(F1/F1)
**


c2n(a/b)
	§1 a-'0'⇒b
		↑(b<10)2
		a-'A'+10⇒b
		↑(a<'Z')2
		a-'a'+10⇒b
	§2 
**




*** Дихотомический алг-тм возведения в степень числа
*** x - число возводимое в степень, y - степень этого числа, m - модуль
pow(x, y, m/z)
	Oj ∆j x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i *** /'j = '>C *printf(j/) /'\n'>C ∆j
		 ↑(i>y)5 q*q:m Z⇒q *** /'q = '>C *Hprintf(q/) /'\n'>C
		 i&y↪3 z*q:m Z⇒z *** /'z = '>C *Hprintf(z/) /'\n'>C
		 →3
	§5
**

pow_kostyl(x, y, m/z)
	@+L1(2)
	@+L2(2)
	@+L3(2)
	@+L4(4)
	x⇒L1.0 y⇒L2.0 m⇒L3.0 1⇒Q1⇒Q2⇒Q3
	*powBN(L1, L2, L3/L4)
	L4.0⇒z
**

*** наверное не работает, надо проверять 02.12.2015
pow1(x, y/L1)
	@+L2()
	@+L3()
	x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i ↑(i>y)5 q*q⇒q *** *printf(q/) /'\n'>C
		 i&y↪3 z*q⇒z *** *printf(z/) /'\n'>C
		 →3
	§5
**

pervec(F1/F1)
	Oi Q1-1⇒j
	§1 ↑(i≥j)2 F1i⇒t F1j⇒F1i t⇒F1j ∆i ∇j →1
	§2
**





*** на входе всегда нечётное число
*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
*** tdMeth(n/L2)
*** tridMeth(n/L2)
*** tdAlg(n/L2)
trial_division_method(n/L2)
	
	@+L1(4)
	3⇒L1.0 5⇒L1.1 7⇒L1.2 11⇒L1.3 4⇒Q1
	
	↑(n<2)6
	*** n;2⇒k ↑(k=0)4 *** k↪4 одно и тоже с ↑(k=0)4, но не работает
	Oi⇒j *** возможно придётся i присваивать 1
	§1 ↑(n=1)7
	§2 n;L1i⇒r n/L1i⇒q ↑(r≠0)4
	§3 L1i⇒L2j ∆j q⇒n →1
	§4 ↑(L1i≥q)5
		 ∆i ↑(i<Q1)2 Oi *recalc_efficients(L1/L1) →1 *** возможно придётся i присваивать 1
	§5
		 n⇒L2j ∆j →7
	§6 /'ОШИБКА: Число должно быть больше 1\n'>C
	§7 j⇒Q2
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method для маленьких чисел
recalc_efficients(L1/L1)
	*** Q1⇒t t-1⇒l t;2⇒t L1l⇒l 4⇒d Oi
	Q1⇒t-1⇒l t;2⇒t L1l⇒l 4⇒d Oi
	↑(t≠0)2
	§1 2⇒d
	§2 l+d⇒L1i⇒l ∆i d;4+2⇒d ↑(i<Q1)2 *** Oi
	§3 *** *printf(L1i/) /' '>C ∆i ↑(i<Q1)3 /'\n'>C
**


*** сделан не правильно
*** не должно быть делений или сведение их к минимуму, пересмотреть
*** основание системы счисления не передавать аргументом
barret_alg(x, m, b, z/r)
	↑(4>b)5 Ok⇒r m⇒t
	
	§1 ↑(t=0)2 t/b⇒t ∆k →1
	§2
	k-1⇒t
	*dihotom2(b, t/t)
	x/t*z⇒q k+1⇒p
	*dihotom2(b, p/t)
	q/p⇒q x;t⇒e q*m;t⇒w
	↑(e≥w)3 e-w⇒r →4
	§3 t+e-w⇒r
	§4 ↑(r<m)6 r-m⇒r →4
	§5 /'ERROR: Третий аргумент должен быть больше 3'>C /'\n'>C
	§6
**



*** Тест Миллера-Рабина
*** возвращает значение b равное 1, если вероятно простое, 0, если составное
*** выбран вариант роста a на двойку после 3ёх: 2, 3, 5, 7,....
*** также можно добавить вариант со случайным значением a он закомментирован ниже
*** n - проверяемое число, r - количество раундов
miral(n, r/b)
	*** @+L1(20)
	*** @+L2(20)
	*** @+L3(20)
	*** OQ1⇒Q2 ***⇒Q3
	n-1⇒m Oq⇒s⇒b ∆q
	↑(n=1)5
	*countZeroes(m/s) *** на этой строке считается s - степень двойки (2^s)*t+1
	q<s⇒q m/q⇒t
	*** /'q = '>C *printf(q/) /'\n'>C
	Oi⇒j⇒c ∆c 2⇒a
	§1 ↑(i≥r)4 ↑(a≥m)4
		*** m-1⇒a X;a⇒a ↑(a<2)1 *** поиск псевдослучайного значения от 2 до n-2
		*pow(a, t, n/x)
		*** /'a = '>C *printf(a/) /'\n'>C
		∆i a+c⇒a 2⇒c
		↑(x=1)1 ↑(x=m)1 1⇒j
	§2 ↑(j≥s)5
		 *** x⇒L1.0 n⇒L2.0 1⇒Q1⇒Q2
		 *** /'x = '>C *printf(x/) /'\n'>C
		 *** *pow(x, 2, n/x)
		 x*x:n Z⇒x
		 *** L1*L1;L2⇒L1 L1.0⇒x
		 ↑(x=1)5 ↑(x=m)1 ∆j →2
	§4 ∆b *** /'Вероятно простое\n'>C *** иначе составное
	§5
**



*** формирует список простых чисел в которых k бит
randPrimesList(k, l/L1)
	Oi⇒Q1 ↑(k<2)3 ↑(k>32)3
	§1
		 32-k⇒t k-1⇒c
		 X>t∨1∨Ic⇒t
		 *** /'t = '>C *printf(t/) /'\n'>C
		 *miral(t, 5/b) *** /'b = '>C *printf(b/) /'\n'>C
		 ↑(b=0)2 t⇒L1i ∆i i⇒Q1 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
	§2 ↑(i=l)3 →1
	§3
**



*****************************************************************
***************	Алгоритмы над большими числами	*****************
*****************************************************************



div_mul_test(L1, L2/L3)
	@+L4(100)
	L1⇒L3⇒L4
	L1/L2 *** *HprintfBN(L4/)
	L4;L2 *** *HprintfBN(L3/)
	L1*L2+L4 *** *HprintfBN(L3/)
**

*** randBN(L1/)
randBN(L1/)
	Q1⇒i X
	§1 i↪2 ∇i X⇒L1i →1
	§2
**



*** ввод большого числа [Добавить обработку нуля!!!]
*** k может вернуться больше размерности комплекса F1 => алгоритм не сработает, необходимо проверять в программе, что размер числа > 0
*** big_int_input(L2, F1, i/L2, k) - старое название
inputBN(L2, F1, i/L2, k)
	Oj Ol Os
	*** первая проверка может быть лишняя из-за 8го парраграфа
	↑(Q1=0)6 ↑(i≥Q1)8
	*** /'i= '>C *printf(i/) /'\n'>C
	↑(F1i≠'0')7 ∆i ↑(F1i≠'x')7 ∆i⇒l⇒e
	*** /'e= '>C *printf(e/) /'\n'>C
	
	§10 ↑(l=Q1)11 ↑(F1l=' ')11 ↑(F1l=10)11 ∆l →10
	§11 l⇒k-1⇒i i-e+1/8⇒Q2 i-e+1;8⇒t ∆k Ol OL2l ↑(t=0)1 Q2+1⇒Q2
	§1
		↑(F1i<'0')7 ↑(F1i>'9')2 F1i-'0'⇒x →4
	§2
		↑(F1i<'A')7 ↑(F1i>'F')3 F1i-'A'+10⇒x →4
	§3
		↑(F1i<'a')7 ↑(F1i>'f')7 F1i-'a'+10⇒x
	§4
		x<s⇒x s+4⇒s L2l∨x⇒L2l ∇i ↑(i<e)9 ∆j ↑(j≥8)5 →1
	§5
		∆l OL2l⇒s⇒j →1
	§6
		/'ОШИБКА: Символьный комплекс пустой\n'>C →9
	§7
		/'ОШИБКА: Число не шестнадцатеричное. Возможно не хватает 0x вначале\n'>C OQ2 →9
	§8
		/'ОШИБКА: Символьный комплекс закончился.\n'>C OQ2
	§9 *cutZerosBN(L2/L2)
**




*** вывод большого числа в шестнадцатеричном виде
*** 0x0 будет выводиться только если мощность комплекса Q равна 1
*** если там будет больше элементов и все будут нули, то на выходе получится "0x"
*** printHexBN(L1/)
*** printHBN(L1/)
*** printhBN(L1/)
*** HprintfBN(L1/)
HprintfBN(L1/)
	@+F2(100)
	↑(Q1=0)7
	Oi⇒f 4⇒s Q1-1⇒j 15⇒y '0'@>F2 'x'@>F2
	§1 ↑(i≥8)4
			***/'j= '>C *printf(j/) /'\n'>C
			16<1-s⇒t ***/'t= '>C *printf(t/) /'\n'>C	*** 16 для оптимизации под конкретную архитектуру
			L1j>t⇒x x&y⇒x s+4⇒s ***/'x= '>C *printf(x/) /'\n'>C
			*** *Hprintf(L1j/)
			x↪2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'@>F2 →1
	§3 ∆i ↑(f=0)1 x+'0'@>F2 →1
	§4 ↑(j=0)5 4⇒s ∇j Oi →1 *** ↑(j≥Q1)5
	§5 ↑(Q1>1)6 ↑(L1.0>0)6 '0'@>F2
	§6 /F2>C
	§7
**


*** Дихотомический алг-тм возведения в степень
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z 
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN(L1, L2, L3/L4)
	@+L5(100)
	
	1⇒Q4⇒Q5 Oj
	L1⇒L5 Q3+Q3⇒l *optimize(L5, l/L5) *optimize(L4, l/L4) 1⇒L4.0⇒i⇒s i<1⇒i L2j&1↪1 L1⇒L4 *optimize(L4, l/L4)
	§1 ↑(s≥32)3 L5*L5;L3⇒L5
	   *** /'L5= '>C *HprintfBN(L5/)
		 i&L2j↪2 L5*L4;L3⇒L4
	   *** /'L4= '>C *HprintfBN(L4/)
	§2 ∆s i<1⇒i →1
	§3 ∆j ↑(j≥Q2)4 Os 1⇒i →1
	§4 *cutZerosBN(L4/L4)
**

*** /'d L4= '>C *HprintfBN(L4/)
*** /'Q4= '>C *printf(Q4/) /' '>C
*** /'d L5= '>C *HprintfBN(L5/)


optimize(L1, n/L1)
	Q1⇒i n⇒Q1
	§1 ↑(i>n)2 OL1i ∆i →1
	§2 
**

*** функция отрезает лишние нули и возвращает большое число без первых нулей(изменяет мощность комплекса)
cutZerosBN(L1/L1)
	Q1-1⇒i
	§1 ↑(L1i≠0)2 ↑(i=0)2 i⇒Q1 ∇i →1
	§2
**


*** Дихотомический алг-тм возведения в небольшую степень большого числа
*** L1 - число возводимое в степень, y - степень этого числа, L2 - модуль
*** думаю в нём нет смысла, если использовать метод из pow(), можно убрать модуль, тогда получится большое число в степени "маленького" числа
powBN1(L1, y, L2/L4)
	*** @+L4(100)
	@+L3(100)
	
	1⇒Q4⇒Q5
	L1⇒L3 Q2+Q2⇒l *optimize(L3, l/L3) *optimize(L4, l/L4) 1⇒L4.0⇒i
	y&1↪3 L1⇒L4 *optimize(L4, l/L4)
	§3 i<1⇒i ↑(i>y)5 L3*L3;L2⇒L3
		 *** /'Q5= '>C *printf(Q5/) /'\n'>C
		 i&y↪3 L3*L4;L2⇒L4
		 *** /'L4= '>C *HprintfBN(L4/) /'\n'>C
		 →3
	§5
**


*** Дихотомический алг-тм возведения в степень
*** L1 - число возводимое в степень, L2 - степень этого числа
*** L4 - q, L3 - z 
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN2(L1, L2/L3)
	@+L4(100)
	
	1⇒Q4⇒Q5 Oj
	L1⇒L4 Q3+Q3⇒l *optimize(L4, l/L4) *optimize(L3, l/L3) 1⇒L3.0⇒i⇒s i<1⇒i L2j&1↪1 L1⇒L3 *optimize(L3, l/L3)
	§1 ↑(s≥32)3 L4*L4⇒L4
	   *** /'L4= '>C *HprintfBN(L4/)
		 i&L2j↪2 L4*L3⇒L3
	   *** /'L3= '>C *HprintfBN(L3/)
	§2 ∆s i<1⇒i →1
	§3 ∆j ↑(j≥Q2)4 Os 1⇒i →1
	§4 *cutZerosBN(L3/L3)
**


*** проверка, что 2 больших числа равны
BN_eq(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ↑(Q2<Q1)2 Q1⇒n
	§1 ↑(L1i≠L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что большое число L1 больше числа L2
BN_gr(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 Ob Q1⇒n
	§1 ↑(L1i<L2i)2 ∆b ↑(L2i<L1i)2 Ob ∆i ↑(i<n)1
	§2
**

*** проверка, что большое число L1 меньше числа L2
BN_less(L1, L2/b)
	Ob⇒i
	↑(Q1>Q2)2 ∆b ↑(Q2>Q1)2 Ob Q1⇒n
	§1 ↑(L1i>L2i)2 ∆b ↑(L2i>L1i)2 Ob ∆i ↑(i<n)1
	§2
**

*** проверка, что большое число L1 больше ил равно числу L2
BN_greq(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 Ob Q1⇒n
	§1 ↑(L1i<L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что большое число L1 меньше или равно числу L2
BN_leq(L1, L2/b)
	Ob⇒i
	↑(Q1>Q2)2 ∆b ↑(Q2>Q1)2 Ob Q1⇒n
	§1 ↑(L1i>L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что 2 больших числа не равны
BN_neq(L1, L2/b)
	Ob⇒i ∆b
	↑(Q1<Q2)2 ↑(Q2<Q1)2 Q1⇒n
	§1 ↑(L1i≠L2i)2 ∆i ↑(i<n)1 Ob
	§2
**



********************************************************
****************	Алгоритмы закончились	****************
********************************************************


main(/)
   @+F1(1000) @+F2(100)
   @'liblf.l'>F2  /F2>C /'\n'>C
   *fopen(F2,0/a)
   *peper(a/)
   *freadf(a,F1,0,150/b)
   *peper(b/)
   *fclose(a/) OQ2
   @'liblf.txt'>F2 /F2>C /'\n'>C
   *fopen(F2,1/a)
   *peper(a/)
   *fwritef(a,F1,0,150/b)
   *peper(b/)
   **
********************************************************************
*** работа с файлами
********************************************************************
*** Открытие файла
*** F1 - имя файла (в текущем каталоге)
*** r - режим открытия: 0 - чтение, 1 - запись, 2 - чтение/запись
*** n  - дескриптор файла (<0 при отказе)
********************************************************************
fopen(F1,r/n)
   0@>F1
   {mov eax,5}
   {mov ebx,[ebp+220]}
   {mov ecx,[ebp+72]}
   {int 80h}
   {mov [ebp+56],eax}
   **
********************************************************************
*** Закрытие файла
*** n  - дескриптор файла
********************************************************************
fclose(n/)
   {mov eax,6}
   {mov ebx,[ebp+56]}
   {int 80h}
   **
********************************************************************
*** Чтение из файла в символьный комплекс
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого считанного байта
*** l - число запрашиваемых байт
*** k - число считанных байтов (код ошибки для <0)
********************************************************************
freadf(n,F1,b,l/k)
   {mov eax,3}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **
********************************************************************
*** Запись из символьного комплекса в файл
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого записываемого байта
*** l - число записывемых байт
*** k - число записанных байтов (код ошибки для <0)
********************************************************************
fwritef(n,F1,b,l/k)
   {mov eax,4}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **

   
   
   
   
   
   
   
   
   
*** Ошибки:


matrixoutput(L1,m,n/) 
 @+F2(34)
 Oa
 §1 *binperemtostr(L1a,n/F2) ∆a
 §2 /F2>C /'\n'>C ↑(a<m)1 **



binstrtoperem(F1/x)
 Oi
 Ox
 Q1-1⇒j
*** Q1-1⇒i
 §1 ↑(F1i='0')2 x|Ij⇒x
 §2 ∇j ∆i ↑(i<Q1)1 **




out3(a,b,n/F1)
 OQ1
 n-1⇒i
 §1 a&Ii⇒x x↦2 '1'@>F1 ↑(i=0)3 ∇i →1
 §2 '0'@>F1 ↑(i=0)3 ∇i →1
 §3 /'a⇒ ' /F1>C /'\n'>C
 OQ1
 n-1⇒i
 §4 b&Ii⇒x x↦5 '0'@>F1 ↑(i=0)6 ∇i →1
 §5 '1'@>F1 ↑(i=0)6 ∇i →4
 §6 /'b⇒ ' /F1>C /'\n'>C **



*** вывод булевого вектора на экран
printbv(a, n/)
    31⇒i ∇n
 §1 ↑(i>n)3
    a&Ii ↪2 /' 1'>C →3
 §2 /' 0'>C
 §3 i↪4 ∇i →1
 §4 /'\n'>C **

*** вывод булевой матрицы на экран
printbm(L1,n/)
    Oi
 §1 *printbv(L1i,n/) ∆i ↑(i<Q1)1 /'\n'>C **
	

*** перевод числа в строку *** 

***************************************
numout(a/)
	@+F1(10)
	OQ1 
	§1	a/q⇒a Z⇒b *n(b/c) c@>F1 a↦1 
  §2	Oi Q1⇒a-1⇒j 
  §3	↑(i≥j)4  =(F1ij) ∆i ∇j →3 
  §4   ** 

 
 
binperemtostr(x,n/F1)
 OQ1
 n-1⇒i
 §1 x&Ii⇒a a↦2 '0'@>F1 ↑(i=0)3 ∇i →1
 §2 '1'@>F1 ↑(i=0)3 ∇i →1
 §3 **